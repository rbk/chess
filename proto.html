<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
    body {

      background-color: #444;
      color: #ffffff;
    }
    </style>
  </head>
  <body>


<script>
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
function Chess() {
  return {
    pieces: [],
    user1: {
      army: [
        {
          name: "pawn",
          advanced: false,
          direction: "-",
          position: {x:0,y:6},
          moves: [],
        },
        {
          name: "pawn",
          advanced: false,
          direction: "-",
          position: {x:0,y:1},
          moves: [
            {
              // Calculate moves
              coordinates: {y:-1, x:0}, // FACT - possible position
              capture: false, // FACT - if object, is it yours? is it attackable

              // Calculate other possibilites in secondary loop
              in_danger: false, // FACT - check whole board for possible attack??
              place_opponent_in_check: false, // FACT- How???? If can attack
              protected: false, // FACT
            }
          ],
        }
      ]
    },
    startingBoard: [
      ["R1", "K1", "B1", "W1", "Q1", "B1", "K1", "R1"],
      ["P1", "P1", "P1", "P1", "P1", "P1", "P1", "P1"],
      ["00", "00", "00", "00", "00", "00", "00", "00"],
      ["00", "00", "00", "00", "00", "00", "00", "00"],
      ["00", "00", "00", "00", "00", "00", "00", "00"],
      ["00", "00", "00", "00", "00", "00", "00", "00"],
      ["P2", "P2", "P2", "P2", "P2", "P2", "P2", "P2"],
      ["R2", "K2", "B2", "W2", "Q2", "B2", "K2", "R2"],
    ],
    place_piece: function() {
      console.log("Print board")
      var y = 0;
      this.board.map((item) => {
        var x = 0;
        item.map( (i) => {
          this.user1.army.map( (piece) => {
            if (piece.position.x == x && piece.position.y == y) {
              this.board[y][x] = piece
            }
          })
          x++
        })
        console.log(item)
        y++
      })
      // console.log(this.board)
    },
    print_board: function() {
      this.board.map((row) => {
        console.log(row)
      })
    },
    calculate_moves: function() {
      // y1, x0
      // for each piece, calc possible moves
      this.user1.army.map((item) => {
        // calc moves for this piece
        item.moves.push({"nothing": "yet"})
      })
    },
    calculate_other_properties: function() {},
    reset_board: function() {
      this.board = [
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["00", "00", "00", "R1", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "P2", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
      ]
    },
    build_pieces: function() {
      let all = [];
      this.board.map((row, y) => {
        row.map((p, x) => {
          let team_number = p.split("")[1]
          let direction = "";
          let name = "";
          if (team_number == "1") {
            direction = "+"
          } else if (team_number == 2){
            direction = "-"
          }
          if (p.match("P")) {
            name = "pawn";
          }
          if (p.match("R")) {
            name = "rook";
          }
          if (p.match("K")) {
            name = "knight";
          }
          if (p.match("Q")) {
            name = "queen";
          }
          if (p.match("W")) {
            name = "king";
          }
          if (p.match("B")) {
            name = "bishop";
          }
          all.push({
            "player" : Number(team_number),
            "direction" : direction,
            "name" : name,
            "coor" : {x: x, y: y},
            "advanced" : false,
            "moves" : []
          })
          x++
        })
        y++
      })
      all.map((piece) => {
        if (piece.name == "pawn") {
          piece.moves = this.pawn(piece)
        }
        if (piece.name == "rook") {
          piece.moves = this.rook(piece)
        }
        if (piece.name == "bishop") {
          piece.moves = this.bishop(piece)
        }
      })
      this.pieces = all;
    },
    findMoves: function(type, limit, piece) {

    },
    allDiagonal: function(piece, limit) {

      let moves = [];
      let moveY;
      let moveX;

      let directions = [
        {x: "+", y: "+"},
        {x: "-", y: "-"},
        {x: "-", y: "+"},
        {x: "+", y: "-"},
      ]

      directions.map((dir) => {

        moveY = piece.coor.y + parseInt(dir.y + 1);
        moveX = piece.coor.x + parseInt(dir.x + 1);

        while (this.isCoordinateValid(moveY, moveX)) {
          if (this.isOpponent(moveY, moveX, piece.player)) {
            let attack = this.board[moveY][moveX]
            this.board[moveY][moveX] = "{" + attack + "}"
            break;
          } else if (this.openSpace(moveY, moveX)){
            this.board[moveY][moveX] = "{p}"
          } else {
            break;
          }
          moveY = moveY + parseInt(dir.y + 1);
          moveX = moveX + parseInt(dir.x + 1);
        }
      })

      return moves

    },
    allLinear: function(piece, limit) {

      console.log(Boolean(limit))

      let moves = [];
      let moveY;
      let moveX;

      let directions = [
        {x: null, y: "+"},
        {x: null, y: "-"},
        {x: "-", y: null},
        {x: "+", y: null},
      ]

      directions.map((dir) => {

        if (dir.y == null) {
          moveY = piece.coor.y;
          moveX = piece.coor.x + parseInt(dir.x + 1);
        } else {
          moveY = piece.coor.y + parseInt(dir.y + 1);
          moveX = piece.coor.x;
        }

        while (this.isCoordinateValid(moveY, moveX)) {
          if (this.isOpponent(moveY, moveX, piece.player)) {
            let attack = this.board[moveY][moveX]
            this.board[moveY][moveX] = "{" + attack + "}"
            break;
          } else if (this.openSpace(moveY, moveX)){
            this.board[moveY][moveX] = "{p}"
          } else {
            break;
          }
          if (dir.y == null) {
            moveX = moveX + parseInt(dir.x + 1);
          } else {
            moveY = moveY + parseInt(dir.y + 1);
          }
        }
      })

      return moves;

    },
    rook: function(rook) {
      return this.allLinear(rook, 0)
    },
    bishop: function(bishop) {
      return this.allDiagonal(bishop)

      // type(s), limit
      this.findMoves("diagonal", 0) // bishop
      this.findMoves("linear", 0) // rook
      this.findMoves(["diagonal", "linear"], 1) // king
      this.findMoves(["diagonal", "linear"], 0) // queen
      this.findMoves("knight", 0) // knight
      this.findMoves("pawn", 1) // pawn
    },
    pawn: function(pawn) {
      let moves = [];
      let moveY;
      let moveX;
      let canMoveTwoPlaces = true;

      moveY = pawn.coor.y + parseInt(pawn.direction + 1);
      moveX = pawn.coor.x;
      if (this.openSpace(moveY, moveX)) {
        moves.push({
          coordinates: {x: moveX, y: moveY},
          capture: false
        })
      } else {
        canMoveTwoPlaces = false;
      }

      // IGNORE INITAL DOUBLE SPACE MOVE
      // if (!pawn.advanced && canMoveTwoPlaces) {
      //   moveY = pawn.coor.y + parseInt(pawn.direction + 2);
      //   moveX = pawn.coor.x;
      //   if (this.openSpace(moveY, moveX)) {
      //     moves.push({
      //       coordinates: {x: moveX, y: moveY},
      //       capture: false
      //     })
      //   }
      // }

      // diag right
      moveY = pawn.coor.y + parseInt(pawn.direction + 1);
      moveX = pawn.coor.x + 1;
      if (this.isOpponent(moveY, moveX, pawn.player)) {
        moves.push({
          coordinates: {x: moveX, y: moveY},
          capture: true
        })
      }

      // diag left
      moveY = pawn.coor.y + parseInt(pawn.direction + 1);
      moveX = pawn.coor.x - 1;
      if (this.isOpponent(moveY, moveX, pawn.player)) {
        moves.push({
          coordinates: {x: moveX, y: moveY},
          capture: true
        })
      }

      return moves
    },
    reachedOpponent: function(y, x, player) {
      if (!this.isCoordinateValid(y,x)) {
        return false;
      }
      if (!this.board[y][x].match(player)) {
        return false;
      }
      return false;
    },
    isCoordinateValid: function(y, x) {
      if (this.board[y] && this.board[y][x]) {
        return true;
      }
      return false;
    },
    openSpace: function(y, x) {
      if (!this.isCoordinateValid(y,x)) {
        return false;
      }
      if (this.board[y][x] != "00") {
        return false;
      }
      return true;
    },
    isOpponent: function(y, x, player) {
      if (!this.isCoordinateValid(y,x)) {
        return false;
      }
      if (this.board[y][x].match(player)) {
        return false;
      }
      if (this.board[y][x].match("00")) {
        return false;
      }
      return true;
    },
    print_moves: function(y, x) {
      let boardClone = JSON.stringify(this.board);
      boardClone = JSON.parse(boardClone)
      this.pieces.map((piece) => {
        if (piece.coor.y == y && piece.coor.x == x) {
          console.log(piece)
          if (!piece.moves) {
            return false;
          }
          piece.moves.map((move) => {
            if (move.capture) {
              let attack = boardClone[move.coordinates.y][move.coordinates.x]
              boardClone[move.coordinates.y][move.coordinates.x] = "{"+attack+"}"
            } else {
              boardClone[move.coordinates.y][move.coordinates.x] = "{m}"
            }
          })
          boardClone.map((row) => {
            console.log(row)
          })
        }
      })
    }

  }
}

var c = Chess();
c.reset_board();
c.build_pieces();
c.calculate_moves();
c.calculate_other_properties();

c.print_board();
console.log("------------------------")
// c.print_moves(3,3);
// c.print_moves(7,0);


</script>



  </body>
</html>
