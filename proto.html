<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
    body {

      background-color: #444;
      color: #ffffff;
    }
    </style>
  </head>
  <body>


<script>
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
function Chess() {
  return {
    pieces: [],
    user1: {
      army: [
        {
          name: "pawn",
          advanced: false,
          direction: "-",
          position: {x:0,y:6},
          moves: [],
        },
        {
          name: "pawn",
          advanced: false,
          direction: "-",
          position: {x:0,y:1},
          moves: [
            {
              // Calculate moves
              coordinates: {y:-1, x:0}, // FACT - possible position
              capture: false, // FACT - if object, is it yours? is it attackable

              // Calculate other possibilites in secondary loop
              in_danger: false, // FACT - check whole board for possible attack??
              place_opponent_in_check: false, // FACT- How???? If can attack
              protected: false, // FACT
            }
          ],
        }
      ]
    },
    place_piece: function() {
      console.log("Print board")
      var y = 0;
      this.board.map((item) => {
        var x = 0;
        item.map( (i) => {
          this.user1.army.map( (piece) => {
            if (piece.position.x == x && piece.position.y == y) {
              this.board[y][x] = piece
            }
          })
          x++
        })
        console.log(item)
        y++
      })
      // console.log(this.board)
    },
    print_board: function() {
      this.board.map((row) => {
        console.log(row)
      })
    },
    calculate_moves: function() {
      // y1, x0
      // for each piece, calc possible moves
      this.user1.army.map((item) => {
        // calc moves for this piece
        item.moves.push({"nothing": "yet"})
      })
    },
    calculate_other_properties: function() {

    },
    reset_board: function() {
      this.board = [
        ["00", "K1", "B1", "W1", "Q1", "B1", "K1", "R1"],
        ["00", "P1", "P1", "P1", "P1", "P1", "P1", "P1"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["P1", "00", "00", "R1", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["00", "00", "00", "00", "00", "00", "00", "00"],
        ["P2", "P2", "P2", "P2", "P2", "P2", "P2", "P2"],
        ["R2", "K2", "B2", "W2", "Q2", "B2", "K2", "R2"],
      ]
    },
    build_pieces: function() {
      let all = [];
      let y = 0;
      this.board.map((row) => {

        let x = 0;
        row.map((p) => {
          let team_number = p.split("")[1]
          let direction = "";
          let name = "";
          if (team_number == "1") {
            direction = "+"
          } else if (team_number == 2){
            direction = "-"
          }
          if (p.match("P")) {
            name = "pawn";
          }
          if (p.match("R")) {
            name = "rook";
          }
          if (p.match("K")) {
            name = "knight";
          }
          if (p.match("Q")) {
            name = "queen";
          }
          if (p.match("W")) {
            name = "king";
          }
          if (p.match("B")) {
            name = "bishop";
          }
          all.push({
            "player" : Number(team_number),
            "direction" : direction,
            "name" : name,
            "coor" : {x: x, y: y},
            "advanced" : false,
            "moves" : []
          })
          x++
        })
        y++
      })
      // console.log(all)
      // all[50].moves = this.pawn(all[50])
      all.map((piece) => {
        if (piece.name == "pawn") {
          piece.moves = this.pawn(piece)
        }
        if (piece.name == "rook") {
          piece.moves = this.rook(piece)
        }
      })
      this.pieces = all;
    },
    // write logic for possible moves for rook
    rook: function(rook) {
      let moves = []
      let moveY;
      let moveX;
      let attack;

      // if (rook.coor.y != 3) {
      //   return []
      // }

      // Down
      moveY = rook.coor.y + 1;
      moveX = rook.coor.x;
      while (this.isCoordinateValid(moveY, moveX)) {
        if (this.isOpponent(moveY, moveX, rook.player)) {
          // en capsule this in brackets
          // push attack move to moves list
          let attack = this.board[moveY][moveX]
          this.board[moveY][moveX] = "{" + attack + "}"
          break;
        } else if (this.openSpace(moveY, moveX)){
          // push regular move
          this.board[moveY][moveX] = "{p}"
        }
        moveY++;
      }

      // Up
      moveY = rook.coor.y - 1;
      moveX = rook.coor.x;
      while (this.isCoordinateValid(moveY, moveX)) {
        if (this.isOpponent(moveY, moveX, rook.player)) {
          let attack = this.board[moveY][moveX]
          this.board[moveY][moveX] = "{" + attack + "}"
          break;
        } else if (this.openSpace(moveY, moveX)){
          this.board[moveY][moveX] = "{p}"
        }
        moveY--;
      }

      // Right
      moveY = rook.coor.y;
      moveX = rook.coor.x + 1;
      while (this.isCoordinateValid(moveY, moveX)) {
        if (this.isOpponent(moveY, moveX, rook.player)) {
          let attack = this.board[moveY][moveX]
          this.board[moveY][moveX] = "{" + attack + "}"
          break
        } else if (this.openSpace(moveY, moveX)){
          this.board[moveY][moveX] = "{p}"
        }
        moveX++;
      }

      // Left
      moveY = rook.coor.y;
      moveX = rook.coor.x - 1;
      while (this.isCoordinateValid(moveY, moveX)) {
        if (this.isOpponent(moveY, moveX, rook.player)) {
          let attack = this.board[moveY][moveX]
          this.board[moveY][moveX] = "{" + attack + "}"
          break;
        } else if (this.openSpace(moveY, moveX)){
          this.board[moveY][moveX] = "{p}"
        }
        moveX--;
      }

      return moves
    },
    pawn: function(pawn) {
      let moves = [];
      let moveY;
      let moveX;
      let canMoveTwoPlaces = true;

      moveY = pawn.coor.y + parseInt(pawn.direction + 1);
      moveX = pawn.coor.x;
      if (this.openSpace(moveY, moveX)) {
        moves.push({
          coordinates: {x: moveX, y: moveY},
          capture: false
        })
      } else {
        canMoveTwoPlaces = false;
      }

      // IGNORE INITAL DOUBLE SPACE MOVE
      // if (!pawn.advanced && canMoveTwoPlaces) {
      //   moveY = pawn.coor.y + parseInt(pawn.direction + 2);
      //   moveX = pawn.coor.x;
      //   if (this.openSpace(moveY, moveX)) {
      //     moves.push({
      //       coordinates: {x: moveX, y: moveY},
      //       capture: false
      //     })
      //   }
      // }

      // diag right
      moveY = pawn.coor.y + parseInt(pawn.direction + 1);
      moveX = pawn.coor.x + 1;
      if (this.isOpponent(moveY, moveX, pawn.player)) {
        moves.push({
          coordinates: {x: moveX, y: moveY},
          capture: true
        })
      }

      // diag left
      moveY = pawn.coor.y + parseInt(pawn.direction + 1);
      moveX = pawn.coor.x - 1;
      if (this.isOpponent(moveY, moveX, pawn.player)) {
        moves.push({
          coordinates: {x: moveX, y: moveY},
          capture: true
        })
      }

      return moves
    },
    reachedOpponent: function(y, x, player) {
      if (!this.isCoordinateValid(y,x)) {
        return false;
      }
      if (!this.board[y][x].match(player)) {
        return false;
      }
      return false;
    },
    isCoordinateValid: function(y, x) {
      if (this.board[y] && this.board[y][x]) {
        return true;
      }
      return false;
    },
    openSpace: function(y, x) {
      if (!this.isCoordinateValid(y,x)) {
        return false;
      }
      if (this.board[y][x] != "00") {
        return false;
      }
      return true;
    },
    isOpponent: function(y, x, player) {
      if (!this.isCoordinateValid(y,x)) {
        return false;
      }
      if (this.board[y][x].match(player)) {
        return false;
      }
      if (this.board[y][x].match("00")) {
        return false;
      }
      return true;
    },
    print_moves: function(y, x) {
      let boardClone = JSON.stringify(this.board);
      boardClone = JSON.parse(boardClone)
      this.pieces.map((piece) => {
        if (piece.coor.y == y && piece.coor.x == x) {
          console.log(piece)
          if (!piece.moves) {
            return false;
          }
          piece.moves.map((move) => {
            boardClone[move.coordinates.y][move.coordinates.x] = "{p}"
          })
          boardClone.map((row) => {
            console.log(row)
          })
        }
      })
    }

  }
}

var c = Chess();
c.reset_board();
c.build_pieces();
c.calculate_moves();
c.calculate_other_properties();

// c.print_board();
console.log("------------------------")
c.print_moves(3,3);
</script>



  </body>
</html>
